<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>TGW3D-8a · CPD-TGW3D-8a.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img src="assets/logo.png" alt="CPD-TGW3D-8a.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">CPD-TGW3D-8a.jl</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li class="is-active"><a class="tocitem" href="arrangement.html">TGW3D-8a</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Stato-dell&#39;arte"><span>Stato dell&#39;arte</span></a></li><li><a class="tocitem" href="#Complessi-di-catene-e-complessi-di-celle"><span>Complessi di catene e complessi di celle</span></a></li><li><a class="tocitem" href="#Complessi-di-celle"><span>Complessi di celle</span></a></li><li><a class="tocitem" href="#Catene-e-Disposizioni"><span>Catene e Disposizioni</span></a></li><li class="toplevel"><a class="tocitem" href="#Calcolo-dei-confini"><span>Calcolo dei confini</span></a></li><li class="toplevel"><a class="tocitem" href="#Algoritmo-Topological-Gift-Wrapping-TGW"><span>Algoritmo Topological Gift Wrapping - TGW</span></a></li><li class="toplevel"><a class="tocitem" href="#Funzioni-del-progetto"><span>Funzioni del progetto</span></a></li><li class="toplevel"><a class="tocitem" href="#Analisi-prestazioni"><span>Analisi prestazioni</span></a></li><li class="toplevel"><a class="tocitem" href="#Ottimizzazione"><span>Ottimizzazione</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="arrangement.html">TGW3D-8a</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="arrangement.html">TGW3D-8a</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/not-Karot/CPD-TGW3D-8a.jl/blob/master/docs/src/arrangement.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><hr/><p>title: |   Report<br/>  CPD22 - Assignment #3<br/>  Delivery #1 –-</p><p>::: titlepage <img src="images/logo-roma-tre-blu-corretto-500x271.jpg" alt="image"/><br/>[Magistrale in ingnegneria informatica]{.smallcaps}</p><p>::: center Calcolo parallelo e distribuito<br/><strong>LAR - Topological gift wrapping in 3D</strong><br/><em>Gruppo 8a</em><br/>:::</p><p><br/> ::: tabularx 360ptl c c c<br/>cName &amp; Student ID<br/>Ennio Malvati &amp; 484998<br/>Gianluca Di Lorenzo &amp; 583630<br/>Raffaele Scarano &amp; 576304<br/> <br/>::: :::</p><h1 id="Introduzione"><a class="docs-heading-anchor" href="#Introduzione">Introduzione</a><a id="Introduzione-1"></a><a class="docs-heading-anchor-permalink" href="#Introduzione" title="Permalink"></a></h1><p>Il dominio dello schema di rappresentazione è attualmente limitato all&#39;Algebra Booleana dei poliedri PL, che possono essere disconnessi e/o non-varianti. Gli elementi di questa algebra sono in corrispondenza uno-ad-uno, biunivoca, con le 3-chains complexes, ossia i complessi di catene di 3 dimensioni, usando le basi p-chains (p-celle, con p = 0,...,3) con cui sono connesse.<br/>Data una qualsiasi raccolta di modelli di questo dominio, utilizzando l&#39;approccio di Paoluzzi, costruiamo la rappresentazione LAR della loro disposizione in <span>$E^3$</span>, includendo il complesso di tre-catene con <span>$\delta_p$</span> operatori rappresentati da matrici sparse <em>(si ricordi che le matrici sparse sono matrici con molti elementi non significativi).</em> 3-cells e le 3-chains elementari in LAR sono in corrispondenza uno-ad-uno con gli atomi dell&#39;Algebra Booleana dei CSG . Per cui ogni solido 3D in questa algebra booleana può essere rappresentato sia da una stringa di bit che ne indica la struttura in termini di atomi, cioè da una 3-chains coerentemente orientata, sia dal suo 2-ciclo orientato al limite.</p><h1 id="Stato-dell&#39;arte"><a class="docs-heading-anchor" href="#Stato-dell&#39;arte">Stato dell&#39;arte</a><a id="Stato-dell&#39;arte-1"></a><a class="docs-heading-anchor-permalink" href="#Stato-dell&#39;arte" title="Permalink"></a></h1><h2 id="Complessi-di-catene-e-complessi-di-celle"><a class="docs-heading-anchor" href="#Complessi-di-catene-e-complessi-di-celle">Complessi di catene e complessi di celle</a><a id="Complessi-di-catene-e-complessi-di-celle-1"></a><a class="docs-heading-anchor-permalink" href="#Complessi-di-catene-e-complessi-di-celle" title="Permalink"></a></h2><p>Un complesso è un insieme S con grado <span>$S = {S _i }$</span> . Verranno utilizzati due tipi di complessi diversi ma intrecciati, in particolare complessi cellulari e complessi di catene. Le loro definizioni ed alcuni concetti correlati vengono forniti in questa sezione. Le <span>$lettere$</span> <span>$greche$</span> saranno usate per le <span>$celle$</span> di uno spazio di partizione e le <span>$lettere$</span> <span>$romane$</span> per le <span>$catene$</span> di celle, codificate come numeri interi con e senza segno o array sparsi di numeri interi con e senza segno.</p><h2 id="Complessi-di-celle"><a class="docs-heading-anchor" href="#Complessi-di-celle">Complessi di celle</a><a id="Complessi-di-celle-1"></a><a class="docs-heading-anchor-permalink" href="#Complessi-di-celle" title="Permalink"></a></h2><p class="math-container">\[Definizione\]</p><p><span>$d$</span> - <span>$Manifold$</span> : un <span>$manifold$</span> è uno spazio topologico che localmente è simile ad un altro spazio topologico ben conosciuto, ad esempio lo spazio euclideo n-dimensionale, ma che globalmente può avere proprietà geometriche differenti, ad esempio può essere <span>$&quot;curvo&quot;$</span> contrariamente allo spazio euclideo. Ogni punto di un <span>$manifold$</span> con <span>$d$</span> dimensioni ha un vicino che è omeomorfo, cioè simile ma non obbligatoriamente uguale del tutto, ad <span>$E^3$</span>, lo spazio euclidiano di d-dimensioni.<br/><br/><span>$Definizione$</span> <span>$Cella$</span> : una <span>$p$</span>-<span>$cella$</span> è un <span>$p$</span> - <span>$manifold$</span> con confini <span>$0\leq$</span> <span>$p\leq$</span>d i quali sono lineari a tratti, connessi, possibilmente non convessi e non contrattabili, non si storcono. Questa definizione si riferisce ai complessi cellulari di questo lavoro e nella nostra rappresentazione ci possono essere celle con buchi interni.<br/>Avremo a che fare con celle Piecewise-Linear (PL) (lineari a tratti) rispettivamente di dimensione 0, 1, 2 e 3. Va notato che le 2-celle e 3-celle possono contenere dei fori (buchi), pur rimanendo collegati. In altre parole, le celle sono poliedri, cioè segmenti, poligoni e poliedri incorporati in uno spazio bi o tridimensionale.<br/><br/><span>$Definizione$</span> <span>$complesso$</span> <span>$cellulare:$</span> un p-complesso cellulare è un insieme finito di celle che hanno al massimo dimensione <span>$p$</span>, insieme alle loro facce <span>$r$</span>-<span>$dimensionali$</span> dei bordi con <span>$0\leq$</span> <span>$r\leq$</span>p. Una faccia è un elemento del confine lineare a tratti della cella, il quale soddisfa le condizioni di compatibilità di confine, che seguono:<br/><br/>- Due <span>$p-celle$</span> sono <span>$boundary$</span>-<span>$compatible$</span> quando i loro punti di intersezione contengono le stesse r-facce.<br/>- Un complesso cellulare di dimensione p è definito <span>$regolare$</span> quando ogni r-cella, con <span>$0\leq$</span> <span>$r\leq$</span>p , è una faccia di una p-cella<br/><br/><span>$Definizione$</span> <span>$Skeleton:$</span> Un <span>$s-skeleton$</span> di un p-complesso <span>$\Lambda_p$</span>, con <span>$s\leq$</span>p, è l&#39;insieme <span>$\Lambda_s$</span> di tutte le r-celle di <span>$\Lambda_p$</span> . Ogni scheletro di un complesso regolare è un sottocomplesso regolare.<br/><br/><span>$Definizione$</span> <span>$Rappresentazione$</span> <span>$Geometrica$</span>: La rappresentazione algebrica lineare (LAR) ha introdotto l&#39;uso di array binari sparsi per calcolare e rappresentare una topologia algebrica di complessi cellulari, ovvero spazi lineari di catene e operatori di (co)confine lineari. (Quindi è una mappatura della disposizione geometrica con matrici/array sparsi binari).<br/><br/><span>$Definizione$</span> <span>$Spazio$</span> <span>$di$</span> <span>$supporto$</span>: Lo spazio di supporto <span>$|\Lambda|$</span> di un complesso cellulare è l&#39;insieme dei punti dell&#39;unione delle proprie celle.<br/>Una <span>$\textbf{p-catena}$</span> può essere vista, forzando il linguaggio, come una **c*ollezione di p-celle.***</p><h2 id="Catene-e-Disposizioni"><a class="docs-heading-anchor" href="#Catene-e-Disposizioni">Catene e Disposizioni</a><a id="Catene-e-Disposizioni-1"></a><a class="docs-heading-anchor-permalink" href="#Catene-e-Disposizioni" title="Permalink"></a></h2><p>La parola <span>$arrangment$</span> è usata nella geometria combinatoria e computazionale, ma anche nella topologia, come sinonimo di partizione spaziale.<br/><br/><span>$Definizione$</span> <span>$Space$</span> <span>$Arrangement:$</span> Data una collezione finita <span>$S$</span> di oggetti geometrici in <span>$E^d$</span> la disposizione <span>$A(S)$</span> è la decomposizione di <span>$E^d$</span> in celle connesse di dimensione <span>$0, 1,…,d$</span> indotte da <span>$S$</span>. Siamo interessati alla partizione dello spazio euclideo indotta da una collezione di complessi cellulari PL.<br/>Data una collezione S di oggetti geometrici, un nuovo metodo per calcolare la topologia della loro disposizione spaziale consiste nel valutare A(S) come complesso di catene C.<br/>Esempio di <span>$3D$</span> <span>$arrangment$</span><br/> ::: center <img src="images/Immagine1.png" alt="image"/> <img src="images/Immagine2.png" alt="image"/> :::</p><p>Nelle figure si mostra la disposizione <span>$A(S)$</span> generata dalla collezione <span>$S$</span> fatta dalle <span>$trenta$</span> facce <span>$2D$</span> di <span>$5$</span> cubi che si intersecano randomicamente. Ogni cella <span>$3D$</span> in <span>$A(S)$</span> è generata da una colonna della matrice sparsa della mappa di confine confine <span>$\delta_3$</span> con valori in (0,1,-1). Nella figura a sinistra si nota la collezione <span>$S$</span> di 5 cubi randomici in <span>$E^3$</span>, mentre quella di destra mostra le 3-celle generate in <span>$E^3$</span> dalla disposizione A(S), (non in scala, e opportunamente ruotate per mostrare meglio la loro forma complessa). Si noti che alcune celle contengono buchi.<br/>Le colonne di <span>$\delta_3$</span> sono 2-cicli, cioè catene chiuse in C2. In particolare, si mostra che le 3-catene sono atomi irriducibili dell&#39;algebra CSG con celle chiuse e regolari. Inoltre, potrebbero essere non convesse ed avere buchi. La cella esterna è il complemento della loro unione. Qualsiasi modello geometrico dell&#39;algebra booleana CSG generata da questi cinque cubi è composto da un sottoinsieme di quei 25 atomi.</p><h3 id="Cicli-e-confini"><a class="docs-heading-anchor" href="#Cicli-e-confini">Cicli e confini</a><a id="Cicli-e-confini-1"></a><a class="docs-heading-anchor-permalink" href="#Cicli-e-confini" title="Permalink"></a></h3><p>Due sottospazi altamente utili sono contenuti all&#39;interno di ogni spazio Cp delle catene: i sottospazi dei <span>$cicli$</span> e dei <span>$confini$</span>.<br/><br/><span>$Definizione$</span> <span>$Catene$</span>, <span>$cicli$</span> e <span>$sottospazi$</span> <span>$di$</span> <span>$confine:$</span><br/>Un <span>$p-ciclo$</span> è definito come una p-catena senza confine, per cui è un elemento del kernel <span>$Z_p$</span> di <span>$\delta_p$</span> (gli insiemi rossi della figura). Un p-confine (p-boundary) è una p-catena che è il confine di una (p+1)-catena, per cui è un elemento dell&#39;immagine <span>$B_p$</span> di <span>$\delta_(p+1)$</span>. L&#39;insieme <span>$B_p$</span> è un sottoinsieme del kernel di <span>$\delta_p$</span>, poiché il confine del confine è vuoto.<br/><br/> ::: center <img src="images/Immagine3.png" alt="image"/> :::</p><p><strong>Proprietà</strong> le colonne della matrice <span>$\delta_3^+$</span> sono 2-cicli.<br/>L&#39;algoritmo che implementeremo, cioè il topological-gift-wrapping <strong>TGW</strong> in 3D, produce la matrice sparsa [<span>$\delta_3^+],$</span> proprio partendo dalla matrice sparsa [<span>$\delta_2]$</span>. Più in generale, ogni colonna delle matrici di confine, è un 2-ciclo.<br/><strong>Proprietà</strong> la somma delle righe di <span>$\delta_3$</span> è zero.</p><h1 id="Calcolo-dei-confini"><a class="docs-heading-anchor" href="#Calcolo-dei-confini">Calcolo dei confini</a><a id="Calcolo-dei-confini-1"></a><a class="docs-heading-anchor-permalink" href="#Calcolo-dei-confini" title="Permalink"></a></h1><p>Nella maggior parte dei casi, l&#39;ambiente di calcolo geometrico di destinazione è in grado di visualizzare, più in generale di gestire, un modello solido utilizzando solamente una rappresentazione dei confini/bordi, tipicamente usando una triangolazione. È facile ottenere una tale rappresentazione moltiplicando la matrice dell&#39;operatore 3-boundary (bordi a tre dimensioni) <span>$\delta_3$</span> : <span>$C_3$</span> <span>$\longmapsto$</span> <span>$C_2^\circlearrowleft$</span> per il vettore di coordinate C3 nello spazio dell&#39;espressione solida, calcolato come termine binario nel nostro insieme algebrico<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>.<br/>Una volta ottenuta in questo modo la coordinata designata del vettore di bordo dell&#39;oggetto solido, cioè la 2-catena formata dalle sue 2-celle orientate (le facce), queste devono essere raccolte da colonne in una \&quot;matrice facciale\&quot; sparsa e tradotta nella corrispondente matrice di 1-cicli orientati di spigoli/edge, per moltiplicazioni destre di [<span>$\delta_2$</span>] per la matrice delle facce. I poligoni di confine/boundary generati (corrispondenti alle colonne della matrice prodotto sparsa) saranno normalmente triangolizzati e infine renderizzati dall&#39;hardware grafico o esportati in formati di file grafici standard o qualsiasi altro formato geometrico necessario per l&#39;applicazione prevista.<br/><br/><span>$Definizione$</span> <span>$Complessi$</span> <span>$Geometrici$</span> <span>$LAR$</span>: è utile ricordare che per mostrare una triangolarizzazione di facce di bordo nella loro propria posizione nello spazio, tutte le informazioni geometriche e topologiche necessarie sono contenute all&#39;interno di <span>$evaluated LAR$</span> o in <span>$Geometric Complex$</span> (GC), data la coppia :</p><p>::: center <span>$\mu$</span> : <span>$C_0$</span> <span>$\longmapsto$</span> <span>$E^3$</span>, (<span>$\delta_2$</span>,<span>$\delta_1$</span>, <span>$\delta_0$</span>) <span>$\equiv$</span> <span>$V$</span>, (<span>$CF$</span>, <span>$FE$</span>, <span>$EV$</span>) :::</p><p>dove V è di tipo <span>$Matrix$</span>-<span>$Real$</span> con tre righe e colonne pari alla cardinalità di <span>$C_0$</span> ed inoltre (CF, FE, EV) sono matrici sparse di co-bordi (coboundary). Le coppie ordinate di lettere da V, E, F, C, corrispondono alla sequenza coboundary che segue: Vertici → Bordo (edge) → Facce → Celle espresso attraverso l&#39;ordine sinistrorso Colonna → Riga di mappe matriciali di operatori.<br/><br/><strong>Memorizzazione di Complessi Geometrici Lar:</strong> La topologia di un 3-complesso LAR è completamente rappresentata dagli operatori (<span>$\delta_2$</span>,<span>$\delta_1$</span>, <span>$\delta_0$</span>) , cioè dagli array sparsi (CF, FE, EV), fornendo le incidenze tra vertici, bordi e facce, sia per b-reps (rappresentazione geometrica dai bordi) che per rappresentazioni cellulari.</p><h1 id="Algoritmo-Topological-Gift-Wrapping-TGW"><a class="docs-heading-anchor" href="#Algoritmo-Topological-Gift-Wrapping-TGW">Algoritmo Topological Gift Wrapping - TGW</a><a id="Algoritmo-Topological-Gift-Wrapping-TGW-1"></a><a class="docs-heading-anchor-permalink" href="#Algoritmo-Topological-Gift-Wrapping-TGW" title="Permalink"></a></h1><p>L&#39;algoritmo TGW è descritto in questa sezione, generalizzandolo per lo spazio d-dimensionale. L&#39;input è la matrice sparsa [ <span>$\delta_{d-1}$</span> ], l&#39;output è la matrice [ <span>$\delta_d^+ ]$</span>, dalla d-catena al (d-1)-ciclo orientato.</p><p>::: center <img src="images/Immagine4.png" alt="image"/> :::</p><h1 id="Funzioni-del-progetto"><a class="docs-heading-anchor" href="#Funzioni-del-progetto">Funzioni del progetto</a><a id="Funzioni-del-progetto-1"></a><a class="docs-heading-anchor-permalink" href="#Funzioni-del-progetto" title="Permalink"></a></h1><p>Dopo un&#39;attenta analisi del repository <a href="https://github.com/cvdlab/LinearAlgebraicRepresentation.jl">https://github.com/cvdlab/LinearAlgebraicRepresentation.jl</a>, abbiamo definito il grafo delle dipendenze relativo al progetto a noi assegnato. Il risultato della nostra analisi è la seguente:</p><p>::: center <img src="images/grafo.png" alt="image"/> :::</p><p>Si definiranno ora le funzionalità principali della repository utili ai fini dell&#39;algoritmo <span>$TGW$</span> <span>$3D$</span>.</p><p>La funzione <strong>spatial arrangment</strong> si occupa di partizionare i complessi cellulari, presi in input, con scheletro di dimensione 2 in 3D. Ne segue che un complesso cellulare è <span>$partizionato$</span> quando <span>$l&#39;intersezione$</span> di ogni possibile coppia del complesso risulta <span>$vuota$</span> e <span>$l&#39;unione$</span> di tutte le celle è tutto lo <span>$spazio$</span> <span>$euclideo$</span>. L&#39;output della funzione consiste nella partizione complessa rappresentata da una lista di vertici V e di una catena di bordi <span>$EV$</span>, <span>$FE$</span>, <span>$CF$</span>.<br/><br/><strong>spatial arrangment 1</strong>: questa funzione frammenta le facce delle figure ai fini dell&#39;utilizzo del arrangment planare. A tal fine usa come funzioni di supporto <strong>frag face</strong> e <strong>merge vertices</strong>. Saranno proprio questi i metodi che andremmo ad ottimizare.<br/>1)<strong>frag face</strong>: effettua la trasformazione in 2D delle facce fornite in input tramite il parametro sigma ed infine ogni faccia di questo parametro sigma si interseca con le facce in <em>sp index</em>.<br/>2)<strong>merge vertices</strong>: effettua il merge delle facce vicine, vertici e lati.<br/><strong>spatial arrangment 2</strong>: ricostruisce le facce dei poligoni permettendo il wrapping in 3D.<br/></p><h1 id="Analisi-prestazioni"><a class="docs-heading-anchor" href="#Analisi-prestazioni">Analisi prestazioni</a><a id="Analisi-prestazioni-1"></a><a class="docs-heading-anchor-permalink" href="#Analisi-prestazioni" title="Permalink"></a></h1><p>In questa fase dell&#39;evoluzione del nostro progetto abbiamo scelto di focalizzarci sul miglioramento di due funzioni principali: frag faces e merge vertices. Ai fini dell&#39;ottimizzazione del progetto, ed eventuale valutazione delle prestazioni, abbiamo preso spunto dal libro <em>Julia High Performance</em>. Per quanto riguarda l&#39;ottimizzazione con i Task si è scelto di utilizzare le seguenti <em>macro</em>:</p><ul><li><p><em>\@async</em>: racchiude un Task, si occupa di far iniziare subito   l&#39;attività racchiusa nel task procedendo con qualsiasi operazione   che segue la macro.</p></li><li><p><em>\@sync</em>: racchiude un Task. Ha comportamento opposto a la macro   precedente, infatti aspetta che tutti i task parallelizzati   terminino prima di eseguire il proprio Task.</p></li><li><p><em>\@spawn</em>: crea un Task e lo assegna ad un qualsiasi thread   disponibile. Il Task verrà eseguito quando si libera il thread a cui   è assegnato.</p></li><li><p><em>\@views</em>: converte le operazione di taglio su un array di una data   espressione per poi dare come output una variabile di tipo View</p></li><li><p><em>\@simd</em>: viene utilizzato nei cicli <em>for</em> al fine di dare maggior   libertà nella gestione del ciclo.</p></li><li><p><em>Threads.@threads</em>: questa macro è apposta davanti a un ciclo for   per indicare a Julia che il ciclo è una regione multi-thread.</p></li></ul><p>Per quanto riguarda la valutazione delle prestazioni:</p><ul><li><p><em>\@benchmark</em>: valuta le prestazioni delle funzione che racchiude,   chiamandola più volte ai fini di creare dei campioni per la   valutazione.</p></li><li><p><em>\@btime</em>: simile a benchmark, ma con meno informazioni.Valuta le   prestazioni della funzione svariate volte al fine di ridurre il   rumore.</p></li><li><p><em>\@profile</em>: esegue l&#39;espressione a cui è assegnata collezionando   dei campioni periodicamente in modo tale da mostrare la gerarchia   delle funzioni ed il tempo di esecuzione di ogni riga.</p></li></ul><p><br/></p><h1 id="Ottimizzazione"><a class="docs-heading-anchor" href="#Ottimizzazione">Ottimizzazione</a><a id="Ottimizzazione-1"></a><a class="docs-heading-anchor-permalink" href="#Ottimizzazione" title="Permalink"></a></h1><p>Nel notebook <em>spatial arrangment 1</em> sono stati messe tutte le ottimizzazioni dovute all&#39;analisi del codice iniziale di <em>LAR</em>. Siamo partiti valutando le prestazioni della singola funzione <em>spatial arrangment 1</em> con relativa tipicizzazione. Per la valutazione delle prestazioni si è utilizzata la macro <em>\@btime</em>, metre per la tipicizzazione abbiamo usato la macro <em>\@code warntype</em>. Quest&#39;ultima macro genera una rappresentazione del codice che può essere utile per trovare espressioni che determinano l&#39;incertezza del tipo. Dopo quest&#39;analisi preliminare abbiamo subito migliorato un minimo i tipi di questa funzione ottenendo già un lieve miglioramento. Una volta superata questa fase abbiamo scelto di proseguire con l&#39;ottimizzazione di due funzioni che sono utilizzate all&#39;interno di <em>spatial arrangment 1</em>, che sono: <em>frag faces</em> e <em>merge vertices</em>. Oltre a valutare la tipicizzazione delle due funzioni abbiamo inserito all&#39;interno una parallelizzazione del codice utilizzando due macro: <em>Threads.@threads</em> e <em>\@async</em>. Una volta migliorate le due funzioni si è andato a verificare se effettivamente, dopo le modifiche da noi apportate, ci sia stato un miglioramento della funzione <em>spatial arrangment 1</em>. Si è cercato di testare le funzioni su tutti e tre i nostri calcolatori (due Mac ed un Windows), i quali avevano architetture fisiche differenti. Nel computer con Windows, inoltre, si è utilizzata una virtualizzazione del sistema Linux. Come risultato abbiamo ottenuto una effettiva ottimizzazione su un pc Mac e il Linux virtualizzato, ma in uno dei due Mac le prestazioni sono peggiorate. Si pensa che questo problema sia dovuto all&#39;overhead della gestione dei Task, ma non ne abbiamo l&#39;assoluta certezza. Ad ogni modo, al fine della valutazione delle nostre modifiche al codice si rimanda notebook spatial arrangment.</p><p>::: thebibliography 9 Alberto Paoluzzi,Vadim Shapiro, Antonio DiCarlo, Giorgio Scorzelli and Elia Onofri <em>Finite Algebras for Solid Modeling using Julia&#39;s Sparse Arrays</em>. Repository del <em>Computational Visual Design Lab di Roma Tre</em> <a href="https://github.com/cvdlab/LinearAlgebraicRepresentation.jl">https://github.com/cvdlab/LinearAlgebraicRepresentation.jl</a> Il nostro repository <a href="https://github.com/not-Karot/LinearAlgebraicRepresentation.jl">https://github.com/not-Karot/LinearAlgebraicRepresentation.jl</a> Sengupta, Avik.<em>Julia High Performance : Optimizations, Distributed Computing, Multithreading, and GPU Programming with Julia 1. 0 and Beyond, 2nd Edition. Birmingham : Packt Publishing, Limited, ©2019</em>. :::</p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>Si ricordi che con la notazione C si intende il complesso di catene nel campo binario 1,0 e con <span>$C^\circlearrowleft$</span> si indica il complesso di catene orientato all&#39;interno del campo ternario 0,1,-1 in modo da avere confini orientati. Quindi le matrici di confine generate da TGW sono mappe <span>$C_3$$\longmapsto$$C_2^\circlearrowleft$</span>.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="index.html">« Home</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.19 on <span class="colophon-date" title="Wednesday 15 June 2022 11:51">Wednesday 15 June 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
